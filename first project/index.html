<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2-Player Bouncing Balls Competition</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="A fun 2-player competitive bouncing balls game with animated characters">
    <meta name="theme-color" content="#764ba2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Bouncing Balls">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- PWA Icons -->
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }
        
        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 15px;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            text-align: center;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
        }
        
        .top-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }
        
        .score-board {
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            font-weight: bold;
            text-align: center;
            min-width: 120px;
        }
        
        .sound-controls {
            background: rgba(255,255,255,0.2);
            padding: 10px 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #canvas {
            border: 3px solid white;
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            max-width: 100%;
            height: auto;
        }
        
        .controls {
            margin-top: 15px;
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
        }
        
        .global-controls {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .individual-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .ball-control {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .ball-control h4 {
            margin: 0 0 8px 0;
            color: white;
            font-size: 14px;
        }
        
        label {
            color: white;
            font-weight: bold;
            margin-right: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            font-size: clamp(12px, 2.5vw, 16px);
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            outline: none;
            appearance: none;
            margin: 5px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .value-display {
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            font-size: 12px;
        }
        
        button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(255,255,255,0.3);
        }
        
        button:active {
            background: rgba(255,255,255,0.4);
        }
        
        /* Winner Modal Styles */
        .winner-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }
        
        .winner-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            border: 3px solid white;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.5);
            max-width: 90%;
            animation: celebrateWin 1s ease-out;
        }
        
        @keyframes celebrateWin {
            0% {
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) rotate(5deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        .winner-title {
            font-size: clamp(2rem, 8vw, 4rem);
            margin: 0 0 20px 0;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from {
                text-shadow: 3px 3px 6px rgba(0,0,0,0.5), 0 0 30px rgba(255,255,255,0.5);
            }
            to {
                text-shadow: 3px 3px 6px rgba(0,0,0,0.5), 0 0 50px rgba(255,255,255,0.8);
            }
        }
        
        .winner-score {
            font-size: clamp(1.2rem, 4vw, 2rem);
            margin: 10px 0;
            font-weight: bold;
        }
        
        .winner-buttons {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .winner-button {
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            padding: 12px 24px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .winner-button:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.05);
        }
        
        .fireworks {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: fireworkAnimation 2s ease-out infinite;
        }
        
        @keyframes fireworkAnimation {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: scale(20);
                opacity: 0;
            }
        }
        
        /* Game Mode Selection Styles */
        .mode-selection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            flex-direction: column;
        }
        
        .mode-content {
            background: rgba(255,255,255,0.2);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            border: 3px solid white;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.5);
            max-width: 90%;
            backdrop-filter: blur(10px);
        }
        
        .mode-title {
            font-size: clamp(1.8rem, 6vw, 3rem);
            margin: 0 0 30px 0;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        
        .mode-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .mode-button {
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.3s ease;
            min-width: 180px;
        }
        
        .mode-button:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.05);
        }
        
        .mode-description {
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.9;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .top-controls {
                gap: 10px;
            }
            
            .score-board, .sound-controls {
                padding: 8px 12px;
                min-width: auto;
            }
            
            .controls {
                padding: 10px;
            }
            
            .individual-controls {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .individual-controls {
                grid-template-columns: 1fr;
            }
            
            .top-controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <!-- Game Mode Selection -->
    <div id="modeSelection" class="mode-selection">
        <div class="mode-content">
            <h1 class="mode-title">🏆 Bouncing Balls Race to 10,000! 🏀</h1>
            <p style="font-size: 16px; margin-bottom: 30px;">Choose your game mode:</p>
            
            <div class="mode-buttons">
                <button class="mode-button" onclick="selectGameMode('single')">
                    🤖 Single Player<br>
                    <div class="mode-description">vs Computer AI</div>
                </button>
                <button class="mode-button" onclick="selectGameMode('multiplayer')">
                    👥 Two Players<br>
                    <div class="mode-description">Local Multiplayer</div>
                </button>
            </div>
        </div>
    </div>

    <h1 id="gameTitle" style="display: none;">🏆 2-Player Bouncing Balls Race to 10,000! 🏀</h1>
    
    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="top-controls">
            <div class="score-board">
                <div style="color: #FF69B4; font-weight: bold;">👧 Player 1 (Girl)</div>
                <div>Score: <span id="player1Score">0</span> / 10,000</div>
                <div>Clicks: <span id="player1Clicks">0</span></div>
            </div>
            <div class="score-board">
                <div style="color: #4169E1; font-weight: bold;" id="player2Label">👦 Player 2 (Boy)</div>
                <div>Score: <span id="player2Score">0</span> / 10,000</div>
                <div>Clicks: <span id="player2Clicks">0</span></div>
            </div>
            <div class="sound-controls">
                <label for="soundToggle">Sound:</label>
                <button id="soundToggle">ON</button>
                <input type="range" id="volumeSlider" min="0" max="100" value="50" style="width: 80px;">
            </div>
            <div id="controlsInfo" class="controls-info" style="background: rgba(255,255,255,0.2); padding: 8px 15px; border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3); color: white; text-align: center; font-size: 12px;">
                <strong>🎮 Controls:</strong> 
                <span style="color: #FF69B4;">👧 Player 1: WASD</span> • 
                <span style="color: #4169E1;" id="player2Controls">👦 Player 2: Arrow Keys</span> • 
                Touch & drag on mobile
            </div>
            <div class="controls-info" style="background: rgba(255,215,0,0.3); padding: 8px 15px; border-radius: 15px; backdrop-filter: blur(10px); border: 2px solid #FFD700; color: white; text-align: center; font-size: 12px; margin-top: 10px;">
                <strong>🏆 Win Condition:</strong> First player to reach <strong>10,000 points</strong> wins the game!
            </div>
        </div>
        
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="controls">
            <div class="global-controls">
                <label for="globalSizeSlider">Global Ball Size:</label>
                <input type="range" id="globalSizeSlider" min="10" max="50" value="20">
                <span id="globalSizeValue" class="value-display">20px</span>
                <button id="resetBalls" style="margin-left: 20px;">Reset All Balls</button>
                
                <br><br>
                
                <label for="playerSizeSlider">Players Size:</label>
                <input type="range" id="playerSizeSlider" min="0.5" max="3" step="0.1" value="1.5">
                <span id="playerSizeValue" class="value-display">1.5x</span>
            </div>
            
            <div class="individual-controls" id="individualControls">
                <!-- Individual ball controls will be generated here -->
            </div>
        </div>
    </div>

    <!-- Winner Modal -->
    <div id="winnerModal" class="winner-modal">
        <div class="winner-content">
            <div class="fireworks" id="fireworks"></div>
            <h1 class="winner-title" id="winnerTitle">🎉 WINNER! 🎉</h1>
            <div class="winner-score" id="winnerDetails">
                <div id="winnerPlayer">Player 1 Wins!</div>
                <div>Final Score: <span id="winnerScore">10,000</span> points</div>
                <div>Total Clicks: <span id="winnerClicks">0</span></div>
            </div>
            <div class="winner-buttons">
                <button class="winner-button" onclick="startNewGame()">🔄 New Game</button>
                <button class="winner-button" onclick="backToModeSelection()">🏠 Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize variables
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const globalSizeSlider = document.getElementById('globalSizeSlider');
        const globalSizeValue = document.getElementById('globalSizeValue');
        const playerSizeSlider = document.getElementById('playerSizeSlider');
        const playerSizeValue = document.getElementById('playerSizeValue');
        const player1ScoreElement = document.getElementById('player1Score');
        const player1ClicksElement = document.getElementById('player1Clicks');
        const player2ScoreElement = document.getElementById('player2Score');
        const player2ClicksElement = document.getElementById('player2Clicks');
        const soundToggle = document.getElementById('soundToggle');
        const volumeSlider = document.getElementById('volumeSlider');
        const resetBalls = document.getElementById('resetBalls');
        const individualControls = document.getElementById('individualControls');

        // Game state
        let player1Score = 0;
        let player2Score = 0;
        let player1Clicks = 0;
        let player2Clicks = 0;
        let soundEnabled = true;
        let volume = 0.5;
        let gameWon = false;
        const WINNING_SCORE = 10000;
        let gameMode = null; // 'single' or 'multiplayer'
        let isAIPlayer = false;

        // Player characters
        const player1 = {
            x: canvas.width / 4,
            y: canvas.height - 120,
            width: 60,
            height: 90,
            speed: 5,
            isMoving: false,
            direction: 'right',
            animationFrame: 0,
            walkCycle: 0,
            lastMoveTime: 0,
            scale: 1.5,  // Make the girl bigger
            type: 'girl'
        };

        const player2 = {
            x: (canvas.width / 4) * 3,
            y: canvas.height - 120,
            width: 60,
            height: 90,
            speed: 5,
            isMoving: false,
            direction: 'left',
            animationFrame: 0,
            walkCycle: 0,
            lastMoveTime: 0,
            scale: 1.5,
            type: 'boy'
        };

        // Input handling
        const keys = {};
        let touchStartX = 0;
        let touchStartY = 0;

        // Responsive canvas - optimized for mobile
        function resizeCanvas() {
            const container = canvas.parentElement;
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isPortrait) {
                // Portrait mode - game fills most of screen width
                const maxWidth = Math.min(600, window.innerWidth - 20);
                const maxHeight = Math.min(450, window.innerHeight * 0.5);
                canvas.style.width = maxWidth + 'px';
                canvas.style.height = (maxWidth * 0.75) + 'px';
            } else {
                // Landscape mode - optimized for gameplay
                const maxWidth = Math.min(800, window.innerWidth - 40);
                const maxHeight = Math.min(600, window.innerHeight * 0.7);
                canvas.style.width = maxWidth + 'px';
                canvas.style.height = (maxWidth * 0.75) + 'px';
            }
        }

        // Sound generation using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBounceSound(frequency = 440, duration = 0.1) {
            if (!soundEnabled || volume === 0) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Ball colors
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
            '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'
        ];

        // Ball class
        class Ball {
            constructor(x, y, radius, color, id) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.vx = 0; // Start with no velocity
                this.vy = 0; // Start with no velocity
                this.gravity = 0.2;
                this.friction = 0.99;
                this.bounce = 0.8;
                this.bounceCount = 0;
                this.lastInteraction = 0; // Track when ball was last touched
            }

            update() {
                // Only apply physics if ball has been recently interacted with or has significant velocity
                const hasSignificantVelocity = Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1;
                const recentlyTouched = (Date.now() - this.lastInteraction) < 3000; // 3 seconds
                
                if (hasSignificantVelocity || recentlyTouched) {
                    this.vy += this.gravity;
                    this.vx *= this.friction;
                    this.vy *= this.friction;

                    this.x += this.vx;
                    this.y += this.vy;

                    // Improved boundary detection with randomness to prevent stacking
                    if (this.x + this.radius >= canvas.width) {
                        this.x = canvas.width - this.radius - Math.random() * 3;
                        this.vx = Math.abs(this.vx) * -this.bounce;
                        if (Math.abs(this.vx) < 1) this.vx = -1 - Math.random(); // Minimum bounce
                    }
                    if (this.x - this.radius <= 0) {
                        this.x = this.radius + Math.random() * 3;
                        this.vx = Math.abs(this.vx) * this.bounce;
                        if (Math.abs(this.vx) < 1) this.vx = 1 + Math.random(); // Minimum bounce
                    }
                    if (this.y + this.radius >= canvas.height) {
                        this.y = canvas.height - this.radius - Math.random() * 3;
                        this.vy = Math.abs(this.vy) * -this.bounce;
                        if (Math.abs(this.vy) < 1) this.vy = -1 - Math.random(); // Minimum bounce
                    }
                    if (this.y - this.radius <= 0) {
                        this.y = this.radius + Math.random() * 3;
                        this.vy = Math.abs(this.vy) * this.bounce;
                        if (Math.abs(this.vy) < 1) this.vy = 1 + Math.random(); // Minimum bounce
                    }

                    // Stop very slow movement to prevent endless tiny bounces
                    if (Math.abs(this.vx) < 0.1) this.vx = 0;
                    if (Math.abs(this.vy) < 0.1) this.vy = 0;
                }

                // Extra safety check to ensure ball stays in bounds
                this.x = Math.max(this.radius + 1, Math.min(canvas.width - this.radius - 1, this.x));
                this.y = Math.max(this.radius + 1, Math.min(canvas.height - this.radius - 1, this.y));
            }

            // Method to handle user click on ball
            onBallClick(playerNumber = 1) {
                if (gameWon) return; // Don't allow scoring if game is won
                
                this.bounceCount++;
                this.lastInteraction = Date.now(); // Mark as recently touched
                const points = Math.floor(this.radius / 5);
                
                if (playerNumber === 1) {
                    player1Clicks++;
                    player1Score += points;
                    player1ScoreElement.textContent = player1Score;
                    player1ClicksElement.textContent = player1Clicks;
                } else {
                    player2Clicks++;
                    player2Score += points;
                    player2ScoreElement.textContent = player2Score;
                    player2ClicksElement.textContent = player2Clicks;
                }
                
                // Play sound with frequency based on ball size and position
                const frequency = 200 + (50 - this.radius) * 10 + (this.y / canvas.height) * 200;
                playBounceSound(frequency, 0.1);
                
                // Native haptic feedback for Android app
                triggerHapticFeedback(points > 6 ? 'success' : 'impact');
                
                // Check for win condition
                checkForWinner();
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius/3, this.y - this.radius/3, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, this.darkenColor(this.color, 0.3));
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x - this.radius/3, this.y - this.radius/3, this.radius/4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
                
                ctx.closePath();
            }

            darkenColor(color, amount) {
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                return `rgb(${Math.floor(r * (1 - amount))}, ${Math.floor(g * (1 - amount))}, ${Math.floor(b * (1 - amount))})`;
            }

            updateRadius(newRadius) {
                this.radius = newRadius;
            }
        }

        // Create balls
        const balls = [];
        const initialRadius = 20;

        function createBalls() {
            balls.length = 0;
            for (let i = 0; i < 10; i++) {
                // Randomize ball size between 15 and 35 pixels
                const randomRadius = Math.floor(Math.random() * 21) + 15; // 15-35 range
                
                let x, y;
                let attempts = 0;
                let validPosition = false;
                
                // Try to find a position that doesn't overlap with existing balls
                while (!validPosition && attempts < 50) {
                    x = Math.random() * (canvas.width - randomRadius * 4) + randomRadius * 2;
                    y = Math.random() * (canvas.height - randomRadius * 4) + randomRadius * 2;
                    
                    validPosition = true;
                    // Check if this position overlaps with existing balls
                    for (let j = 0; j < balls.length; j++) {
                        const dx = x - balls[j].x;
                        const dy = y - balls[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < (randomRadius + balls[j].radius + 10)) { // Dynamic spacing based on ball sizes
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }
                
                // If we couldn't find a good position, use random anyway
                if (!validPosition) {
                    x = Math.random() * (canvas.width - randomRadius * 2) + randomRadius;
                    y = Math.random() * (canvas.height - randomRadius * 2) + randomRadius;
                }
                
                balls.push(new Ball(x, y, randomRadius, colors[i], i));
            }
            createIndividualControls();
        }

        // Create individual ball controls
        function createIndividualControls() {
            individualControls.innerHTML = '';
            balls.forEach((ball, index) => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'ball-control';
                controlDiv.style.borderLeft = `4px solid ${ball.color}`;
                
                controlDiv.innerHTML = `
                    <h4>Ball ${index + 1}</h4>
                    <input type="range" id="ball-${index}" min="5" max="60" value="${ball.radius}">
                    <div class="value-display" id="ball-${index}-value">${ball.radius}px</div>
                `;
                
                individualControls.appendChild(controlDiv);
                
                const slider = document.getElementById(`ball-${index}`);
                const valueDisplay = document.getElementById(`ball-${index}-value`);
                
                slider.addEventListener('input', (e) => {
                    const newRadius = parseInt(e.target.value);
                    ball.updateRadius(newRadius);
                    valueDisplay.textContent = newRadius + 'px';
                });
            });
        }

        // Player functions
        function updatePlayers() {
            if (gameWon) return; // Don't allow movement if game is won
            
            // Player 1 (Girl) - WASD controls
            if (keys['KeyA']) {
                player1.x -= player1.speed;
                player1.isMoving = true;
                player1.direction = 'left';
            }
            if (keys['KeyD']) {
                player1.x += player1.speed;
                player1.isMoving = true;
                player1.direction = 'right';
            }
            if (keys['KeyW']) {
                player1.y -= player1.speed;
                player1.isMoving = true;
            }
            if (keys['KeyS']) {
                player1.y += player1.speed;
                player1.isMoving = true;
            }

            // Player 2 - either human or AI
            if (isAIPlayer) {
                // AI controls Player 2
                aiPlayer.update();
            } else {
                // Human Player 2 (Boy) - Arrow key controls
                if (keys['ArrowLeft']) {
                    player2.x -= player2.speed;
                    player2.isMoving = true;
                    player2.direction = 'left';
                }
                if (keys['ArrowRight']) {
                    player2.x += player2.speed;
                    player2.isMoving = true;
                    player2.direction = 'right';
                }
                if (keys['ArrowUp']) {
                    player2.y -= player2.speed;
                    player2.isMoving = true;
                }
                if (keys['ArrowDown']) {
                    player2.y += player2.speed;
                    player2.isMoving = true;
                }
            }

            // Keep players within canvas bounds
            player1.x = Math.max(player1.width/2, Math.min(canvas.width - player1.width/2, player1.x));
            player1.y = Math.max(player1.height/2, Math.min(canvas.height - player1.height/2, player1.y));
            player2.x = Math.max(player2.width/2, Math.min(canvas.width - player2.width/2, player2.x));
            player2.y = Math.max(player2.height/2, Math.min(canvas.height - player2.height/2, player2.y));

            // Prevent players from overlapping each other
            const dx = player2.x - player1.x;
            const dy = player2.y - player1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = (player1.width/2 * player1.scale) + (player2.width/2 * player2.scale) + 5;
            
            if (distance < minDistance && distance > 0) {
                const overlap = minDistance - distance;
                const separationX = (dx / distance) * (overlap / 2);
                const separationY = (dy / distance) * (overlap / 2);
                
                player1.x -= separationX;
                player1.y -= separationY;
                player2.x += separationX;
                player2.y += separationY;
                
                // Keep them in bounds after separation
                player1.x = Math.max(player1.width/2, Math.min(canvas.width - player1.width/2, player1.x));
                player1.y = Math.max(player1.height/2, Math.min(canvas.height - player1.height/2, player1.y));
                player2.x = Math.max(player2.width/2, Math.min(canvas.width - player2.width/2, player2.x));
                player2.y = Math.max(player2.height/2, Math.min(canvas.height - player2.height/2, player2.y));
            }

            // Check collision with balls for both players
            balls.forEach(ball => {
                // Player 1 collision
                const dx1 = ball.x - player1.x;
                const dy1 = ball.y - player1.y;
                const distance1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                
                if (distance1 < ball.radius + (player1.width/2 * player1.scale)) {
                    ball.onBallClick(1); // Player 1 scores
                    
                    const angle = Math.atan2(dy1, dx1) + (Math.random() - 0.5) * 0.5;
                    const force = 8 + Math.random() * 4;
                    ball.vx = Math.cos(angle) * force;
                    ball.vy = Math.sin(angle) * force;
                    ball.lastInteraction = Date.now(); // Mark as recently touched
                }

                // Player 2 collision
                const dx2 = ball.x - player2.x;
                const dy2 = ball.y - player2.y;
                const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                
                if (distance2 < ball.radius + (player2.width/2 * player2.scale)) {
                    ball.onBallClick(2); // Player 2 scores
                    
                    const angle = Math.atan2(dy2, dx2) + (Math.random() - 0.5) * 0.5;
                    const force = 8 + Math.random() * 4;
                    ball.vx = Math.cos(angle) * force;
                    ball.vy = Math.sin(angle) * force;
                    ball.lastInteraction = Date.now(); // Mark as recently touched
                }
            });
        }

        function drawPlayer(player) {
            ctx.save();
            
            const centerX = player.x;
            const centerY = player.y;
            const time = Date.now() * 0.008;
            const scale = player.scale;
            const isGirl = player.type === 'girl';
            
            // Update animation
            if (player.isMoving) {
                player.walkCycle += 0.2;
            }
            
            // Simple animation values (scaled)
            const bounce = player.isMoving ? Math.sin(player.walkCycle) * 2 * scale : Math.sin(time) * 1 * scale;
            const armSwing = player.isMoving ? Math.sin(player.walkCycle) * 5 * scale : 0;
            
            // Character-specific colors
            const bodyColor = isGirl ? '#FF69B4' : '#4169E1'; // Pink dress for girl, blue shirt for boy
            const hairColor = isGirl ? '#8B4513' : '#654321'; // Brown hair for both, slightly different shades
            const auraColor = isGirl ? 'rgba(255, 192, 203, 0.4)' : 'rgba(65, 105, 225, 0.4)'; // Pink aura for girl, blue for boy
            
            // Body (dress for girl, shirt for boy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            if (isGirl) {
                ctx.ellipse(centerX, centerY + bounce, 15 * scale, 25 * scale, 0, 0, Math.PI * 2);
            } else {
                // Boy's shirt (more rectangular)
                ctx.rect(centerX - 12 * scale, centerY - 10 * scale + bounce, 24 * scale, 30 * scale);
            }
            ctx.fill();
            
            // Pants for boy only
            if (!isGirl) {
                ctx.fillStyle = '#2F4F4F'; // Dark gray pants
                ctx.beginPath();
                ctx.rect(centerX - 8 * scale, centerY + 15 * scale + bounce, 16 * scale, 20 * scale);
                ctx.fill();
            }
            
            // Arms
            ctx.strokeStyle = '#FFDBAC';
            ctx.lineWidth = 5 * scale;
            ctx.lineCap = 'round';
            
            // Left arm
            ctx.beginPath();
            ctx.moveTo(centerX - 12 * scale, centerY - 5 * scale + bounce);
            ctx.lineTo(centerX - 20 * scale + armSwing, centerY + 10 * scale + bounce);
            ctx.stroke();
            
            // Right arm
            ctx.beginPath();
            ctx.moveTo(centerX + 12 * scale, centerY - 5 * scale + bounce);
            ctx.lineTo(centerX + 20 * scale - armSwing, centerY + 10 * scale + bounce);
            ctx.stroke();
            
            // Legs
            const legMove = player.isMoving ? Math.sin(player.walkCycle + Math.PI) * 3 * scale : 0;
            
            // Left leg
            ctx.beginPath();
            ctx.moveTo(centerX - 5 * scale, centerY + 20 * scale + bounce);
            ctx.lineTo(centerX - 5 * scale + legMove, centerY + 35 * scale + bounce);
            ctx.stroke();
            
            // Right leg
            ctx.beginPath();
            ctx.moveTo(centerX + 5 * scale, centerY + 20 * scale + bounce);
            ctx.lineTo(centerX + 5 * scale - legMove, centerY + 35 * scale + bounce);
            ctx.stroke();
            
            // Head
            ctx.fillStyle = '#FFDBAC';
            ctx.beginPath();
            ctx.arc(centerX, centerY - 20 * scale + bounce, 12 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Hair
            ctx.fillStyle = hairColor;
            ctx.beginPath();
            if (isGirl) {
                // Girl's hair with pigtails
                ctx.arc(centerX, centerY - 25 * scale + bounce, 14 * scale, Math.PI, Math.PI * 2);
                ctx.fill();
                
                // Hair pigtails
                ctx.beginPath();
                ctx.arc(centerX - 10 * scale, centerY - 22 * scale + bounce + Math.sin(time * 2) * scale, 3 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 10 * scale, centerY - 22 * scale + bounce + Math.sin(time * 2) * scale, 3 * scale, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Boy's shorter hair
                ctx.arc(centerX, centerY - 23 * scale + bounce, 12 * scale, Math.PI, Math.PI * 2);
                ctx.fill();
                
                // Boy's spiky hair effect
                ctx.beginPath();
                ctx.arc(centerX - 6 * scale, centerY - 28 * scale + bounce, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 6 * scale, centerY - 28 * scale + bounce, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX, centerY - 30 * scale + bounce, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Eyes
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(centerX - 4 * scale, centerY - 20 * scale + bounce, 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 4 * scale, centerY - 20 * scale + bounce, 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye sparkles
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(centerX - 4 * scale, centerY - 21 * scale + bounce, 0.5 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 4 * scale, centerY - 21 * scale + bounce, 0.5 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Smile
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5 * scale;
            ctx.beginPath();
            ctx.arc(centerX, centerY - 15 * scale + bounce, 3 * scale, 0, Math.PI);
            ctx.stroke();
            
            // Blush
            ctx.fillStyle = 'rgba(255, 182, 193, 0.6)';
            ctx.beginPath();
            ctx.arc(centerX - 8 * scale, centerY - 17 * scale + bounce, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 8 * scale, centerY - 17 * scale + bounce, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Character aura
            ctx.strokeStyle = auraColor;
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.arc(centerX, centerY + bounce, 25 * scale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Sparkles when moving (different colors for each character)
            if (player.isMoving) {
                const sparkleColor = isGirl ? 'rgba(255, 215, 0, 0.7)' : 'rgba(0, 191, 255, 0.7)';
                ctx.fillStyle = sparkleColor;
                ctx.beginPath();
                ctx.arc(centerX + Math.sin(time) * 20 * scale, centerY + Math.cos(time) * 20 * scale, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + Math.sin(time + 2) * 15 * scale, centerY + Math.cos(time + 2) * 15 * scale, 1.5 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
            
            player.isMoving = false; // Reset movement flag
            ctx.restore();
        }

        // Ball separation function to prevent overlapping
        function separateBalls() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = ball1.radius + ball2.radius + 2; // Add buffer
                    
                    if (distance < minDistance && distance > 0) {
                        // Balls are overlapping, separate them
                        const overlap = minDistance - distance;
                        const separationX = (dx / distance) * (overlap / 2);
                        const separationY = (dy / distance) * (overlap / 2);
                        
                        // Move balls apart
                        ball1.x -= separationX;
                        ball1.y -= separationY;
                        ball2.x += separationX;
                        ball2.y += separationY;
                        
                        // Add some velocity to keep them moving
                        const pushForce = 2;
                        ball1.vx -= (dx / distance) * pushForce;
                        ball1.vy -= (dy / distance) * pushForce;
                        ball2.vx += (dx / distance) * pushForce;
                        ball2.vy += (dy / distance) * pushForce;
                        
                        // Ensure balls stay in bounds after separation
                        ball1.x = Math.max(ball1.radius + 1, Math.min(canvas.width - ball1.radius - 1, ball1.x));
                        ball1.y = Math.max(ball1.radius + 1, Math.min(canvas.height - ball1.radius - 1, ball1.y));
                        ball2.x = Math.max(ball2.radius + 1, Math.min(canvas.width - ball2.radius - 1, ball2.x));
                        ball2.y = Math.max(ball2.radius + 1, Math.min(canvas.height - ball2.radius - 1, ball2.y));
                    }
                }
            }
        }

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw balls
            balls.forEach(ball => {
                ball.update();
                ball.draw();
            });
            
            // Separate overlapping balls
            separateBalls();
            
            // Update and draw players
            updatePlayers();
            drawPlayer(player1);
            drawPlayer(player2);
            
            requestAnimationFrame(animate);
        }

        // Event listeners
        globalSizeSlider.addEventListener('input', (e) => {
            const newRadius = parseInt(e.target.value);
            globalSizeValue.textContent = newRadius + 'px';
            
            balls.forEach((ball, index) => {
                ball.updateRadius(newRadius);
                const individualSlider = document.getElementById(`ball-${index}`);
                const individualValue = document.getElementById(`ball-${index}-value`);
                if (individualSlider && individualValue) {
                    individualSlider.value = newRadius;
                    individualValue.textContent = newRadius + 'px';
                }
            });
        });

        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.textContent = soundEnabled ? 'ON' : 'OFF';
            soundToggle.style.background = soundEnabled ? 'rgba(0,255,0,0.3)' : 'rgba(255,0,0,0.3)';
        });

        volumeSlider.addEventListener('input', (e) => {
            volume = e.target.value / 100;
        });

        playerSizeSlider.addEventListener('input', (e) => {
            const newScale = parseFloat(e.target.value);
            player1.scale = newScale;
            player2.scale = newScale;
            playerSizeValue.textContent = newScale + 'x';
        });

        resetBalls.addEventListener('click', () => {
            startNewGame();
        });

        // Touch and click interaction
        function handleInteraction(e) {
            if (gameWon) return; // Don't allow interaction if game is won
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const clickX = (clientX - rect.left) * scaleX;
            const clickY = (clientY - rect.top) * scaleY;
            
            balls.forEach(ball => {
                const dx = ball.x - clickX;
                const dy = ball.y - clickY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if user clicked directly on the ball
                if (distance <= ball.radius) {
                    // User clicked on the ball - determine which player gets credit
                    const playerNumber = clickX < canvas.width / 2 ? 1 : 2;
                    ball.onBallClick(playerNumber);
                    
                    // Add velocity to the ball with randomness
                    const randomAngle = (Math.random() - 0.5) * 0.3;
                    const force = 5 + Math.random() * 3;
                    ball.vx += Math.cos(Math.atan2(dy, dx) + randomAngle) * force;
                    ball.vy += Math.sin(Math.atan2(dy, dx) + randomAngle) * force;
                    ball.lastInteraction = Date.now(); // Mark as recently touched
                } else if (distance < 100) {
                    // User clicked near the ball - just add velocity (no score)
                    const randomAngle = (Math.random() - 0.5) * 0.2;
                    const force = 3 + Math.random() * 2;
                    ball.vx += Math.cos(Math.atan2(dy, dx) + randomAngle) * force;
                    ball.vy += Math.sin(Math.atan2(dy, dx) + randomAngle) * force;
                    ball.lastInteraction = Date.now(); // Mark as recently touched
                }
            });
        }

        canvas.addEventListener('click', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction);

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            e.preventDefault();
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                touchStartX = (e.touches[0].clientX - rect.left) * scaleX;
                touchStartY = (e.touches[0].clientY - rect.top) * scaleY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const touchX = (e.touches[0].clientX - rect.left) * scaleX;
                const touchY = (e.touches[0].clientY - rect.top) * scaleY;
                
                // In single player mode, touch controls only player 1
                // In multiplayer mode, left side controls player 1, right side controls player 2
                let targetPlayer;
                if (isAIPlayer) {
                    targetPlayer = player1; // Only control player 1 in AI mode
                } else {
                    targetPlayer = touchX < canvas.width / 2 ? player1 : player2;
                }
                
                // Move player towards touch position
                const dx = touchX - targetPlayer.x;
                const dy = touchY - targetPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    targetPlayer.x += (dx / distance) * targetPlayer.speed;
                    targetPlayer.y += (dy / distance) * targetPlayer.speed;
                    targetPlayer.isMoving = true;
                }
            }
        });

        // Initialize (but don't start game until mode is selected)
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Enable audio context on first user interaction
        document.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });

        // Native app features (Capacitor)
        let Haptics, StatusBar, SplashScreen;
        
        // Initialize Capacitor plugins if available (for native Android app)
        async function initializeNativeFeatures() {
            try {
                if (window.Capacitor) {
                    const { Haptics: HapticsPlugin } = await import('@capacitor/haptics');
                    const { StatusBar: StatusBarPlugin } = await import('@capacitor/status-bar');
                    const { SplashScreen: SplashScreenPlugin } = await import('@capacitor/splash-screen');
                    
                    Haptics = HapticsPlugin;
                    StatusBar = StatusBarPlugin;
                    SplashScreen = SplashScreenPlugin;
                    
                    // Configure status bar for Android
                    await StatusBar.setStyle({ style: 'dark' });
                    await StatusBar.setBackgroundColor({ color: '#667eea' });
                    
                    // Hide splash screen after game loads
                    setTimeout(() => {
                        SplashScreen.hide();
                    }, 1000);
                    
                    console.log('Native features initialized');
                }
            } catch (error) {
                console.log('Running in web mode - native features not available');
            }
        }

        // Native haptic feedback function
        async function triggerHapticFeedback(type = 'light') {
            try {
                if (Haptics && window.Capacitor) {
                    if (type === 'success') {
                        await Haptics.notification({ type: 'success' });
                    } else if (type === 'impact') {
                        await Haptics.impact({ style: 'medium' });
                    } else {
                        await Haptics.impact({ style: 'light' });
                    }
                }
            } catch (error) {
                // Haptics not available, ignore silently
            }
        }

        // Initialize native features when page loads
        initializeNativeFeatures();

        // Game mode selection functions
        function selectGameMode(mode) {
            gameMode = mode;
            isAIPlayer = (mode === 'single');
            
            // Update UI based on game mode
            if (isAIPlayer) {
                document.getElementById('player2Label').innerHTML = '🤖 Computer AI';
                document.getElementById('gameTitle').textContent = '🏆 Single Player Race to 10,000! 🏀';
                document.getElementById('player2Controls').innerHTML = '🤖 Computer AI: Automatic';
                document.getElementById('controlsInfo').innerHTML = `
                    <strong>🎮 Controls:</strong> 
                    <span style="color: #FF69B4;">👧 Player 1: WASD</span> • 
                    <span style="color: #4169E1;">🤖 Computer AI: Automatic</span> • 
                    Touch & drag (controls player 1 only)
                `;
            } else {
                document.getElementById('player2Label').innerHTML = '👦 Player 2 (Boy)';
                document.getElementById('gameTitle').textContent = '🏆 2-Player Bouncing Balls Race to 10,000! 🏀';
                document.getElementById('player2Controls').innerHTML = '👦 Player 2: Arrow Keys';
                document.getElementById('controlsInfo').innerHTML = `
                    <strong>🎮 Controls:</strong> 
                    <span style="color: #FF69B4;">👧 Player 1: WASD</span> • 
                    <span style="color: #4169E1;">👦 Player 2: Arrow Keys</span> • 
                    Touch & drag (left/right sides)
                `;
            }
            
            // Hide mode selection and show game
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('gameTitle').style.display = 'block';
            document.getElementById('gameContainer').style.display = 'flex';
            
            // Start the game
            resizeCanvas();
            createBalls();
            animate();
        }

        function backToModeSelection() {
            // Reset game state
            gameWon = false;
            gameMode = null;
            isAIPlayer = false;
            
            // Hide winner modal and game
            document.getElementById('winnerModal').style.display = 'none';
            document.getElementById('gameTitle').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'none';
            
            // Show mode selection
            document.getElementById('modeSelection').style.display = 'flex';
        }

        // AI Player Logic
        const aiPlayer = {
            targetBall: null,
            lastDecisionTime: 0,
            reactionDelay: 300, // AI reaction time in milliseconds
            skill: 0.8, // AI skill level (0-1, where 1 is perfect)
            
            update() {
                if (!isAIPlayer || gameWon) return;
                
                const currentTime = Date.now();
                
                // Make decisions every few milliseconds
                if (currentTime - this.lastDecisionTime > this.reactionDelay) {
                    this.makeDecision();
                    this.lastDecisionTime = currentTime;
                }
                
                // Move towards target
                this.moveTowardsTarget();
            },
            
            makeDecision() {
                // Find the best ball to target
                let bestBall = null;
                let bestScore = -1;
                
                balls.forEach(ball => {
                    const distance = Math.sqrt(
                        Math.pow(ball.x - player2.x, 2) + 
                        Math.pow(ball.y - player2.y, 2)
                    );
                    
                    // Score based on ball value and distance
                    const ballValue = Math.floor(ball.radius / 5);
                    const score = ballValue / (distance + 1) * this.skill;
                    
                    // Add some randomness to make AI less predictable
                    const randomFactor = 0.7 + Math.random() * 0.6;
                    const finalScore = score * randomFactor;
                    
                    if (finalScore > bestScore) {
                        bestScore = finalScore;
                        bestBall = ball;
                    }
                });
                
                this.targetBall = bestBall;
            },
            
            moveTowardsTarget() {
                if (!this.targetBall) return;
                
                const dx = this.targetBall.x - player2.x;
                const dy = this.targetBall.y - player2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    // Move towards target with some imperfection
                    const moveSpeed = player2.speed * (0.7 + Math.random() * 0.3); // Variable speed
                    const accuracy = this.skill * (0.8 + Math.random() * 0.4); // Variable accuracy
                    
                    player2.x += (dx / distance) * moveSpeed * accuracy;
                    player2.y += (dy / distance) * moveSpeed * accuracy;
                    player2.isMoving = true;
                    
                    // Update direction based on movement
                    player2.direction = dx > 0 ? 'right' : 'left';
                }
            }
        };

        // Winner functions
        function checkForWinner() {
            if (gameWon) return;
            
            let winner = null;
            let winnerScore = 0;
            let winnerClicks = 0;
            let winnerColor = '';
            
            if (player1Score >= WINNING_SCORE) {
                winner = 1;
                winnerScore = player1Score;
                winnerClicks = player1Clicks;
                winnerColor = '#FF69B4';
            } else if (player2Score >= WINNING_SCORE) {
                winner = 2;
                winnerScore = player2Score;
                winnerClicks = player2Clicks;
                winnerColor = '#4169E1';
            }
            
            if (winner) {
                gameWon = true;
                showWinnerModal(winner, winnerScore, winnerClicks, winnerColor);
            }
        }

        function showWinnerModal(playerNumber, score, clicks, color) {
            const modal = document.getElementById('winnerModal');
            const winnerPlayer = document.getElementById('winnerPlayer');
            const winnerScore = document.getElementById('winnerScore');
            const winnerClicks = document.getElementById('winnerClicks');
            const winnerTitle = document.getElementById('winnerTitle');
            
            // Update modal content based on game mode
            let playerName = '';
            if (playerNumber === 1) {
                playerName = '(Girl) 👧';
            } else {
                playerName = isAIPlayer ? '(Computer AI) 🤖' : '(Boy) 👦';
            }
            
            winnerPlayer.textContent = `🎉 Player ${playerNumber} ${playerName} Wins! 🎉`;
            winnerPlayer.style.color = color;
            winnerScore.textContent = score.toLocaleString();
            winnerClicks.textContent = clicks;
            
            // Show modal
            modal.style.display = 'flex';
            
            // Create fireworks
            createFireworks();
            
            // Play celebration sound
            playCelebrationSound();
            
            // Haptic feedback for celebration
            triggerHapticFeedback('success');
        }

        function createFireworks() {
            const fireworksContainer = document.getElementById('fireworks');
            fireworksContainer.innerHTML = '';
            
            const colors = ['#FFD700', '#FF69B4', '#4169E1', '#00FF00', '#FF4500', '#9400D3'];
            
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.left = Math.random() * 100 + '%';
                    firework.style.top = Math.random() * 100 + '%';
                    firework.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    firework.style.animationDelay = Math.random() * 2 + 's';
                    
                    fireworksContainer.appendChild(firework);
                    
                    // Remove firework after animation
                    setTimeout(() => {
                        if (firework.parentNode) {
                            firework.parentNode.removeChild(firework);
                        }
                    }, 2000);
                }, i * 100);
            }
        }

        function playCelebrationSound() {
            // Play a series of celebration notes
            const notes = [523, 659, 784, 1047]; // C, E, G, C (major chord)
            
            notes.forEach((frequency, index) => {
                setTimeout(() => {
                    playBounceSound(frequency, 0.3);
                }, index * 150);
            });
        }

        function startNewGame() {
            // Reset all game state
            gameWon = false;
            player1Score = 0;
            player2Score = 0;
            player1Clicks = 0;
            player2Clicks = 0;
            
            // Update UI
            player1ScoreElement.textContent = player1Score;
            player1ClicksElement.textContent = player1Clicks;
            player2ScoreElement.textContent = player2Score;
            player2ClicksElement.textContent = player2Clicks;
            
            // Reset player positions
            player1.x = canvas.width / 4;
            player1.y = canvas.height - 120;
            player2.x = (canvas.width / 4) * 3;
            player2.y = canvas.height - 120;
            
            // Create new balls
            createBalls();
            
            // Hide modal
            document.getElementById('winnerModal').style.display = 'none';
        }



        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js')
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(function(err) {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button if not already installed
            const installButton = document.createElement('button');
            installButton.textContent = '📱 Install App';
            installButton.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                z-index: 1000;
                background: rgba(255,255,255,0.9);
                border: 2px solid #764ba2;
                color: #764ba2;
                padding: 8px 12px;
                border-radius: 10px;
                font-weight: bold;
                cursor: pointer;
                font-size: 12px;
            `;
            
            installButton.addEventListener('click', () => {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                        installButton.remove();
                    }
                    deferredPrompt = null;
                });
            });
            
            document.body.appendChild(installButton);
        });
    </script>
</body>
</html> 